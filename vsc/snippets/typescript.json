{
	/*
	// Place your snippets for TypeScript here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	"Print to console": {
		"prefix": "log",
		"body": [
			"console.log('$1');",
			"$2"
		],
		"description": "Log output to console"
	}
*/
	"module *.d.ts template (function)": {
		"prefix": "module function",
		"body": [
			"// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]",
			"// Project: [~THE PROJECT NAME~]",
			"// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>",
			"",
			"/*~ This is the module template file for function modules.",
			" *~ You should rename it to index.d.ts and place it in a folder with the same name as the module.",
			" *~ For example, if you were writing a file for \"super-greeter\", this",
			" *~ file should be 'super-greeter/index.d.ts'",
			" */",
			"",
			"/*~ Note that ES6 modules cannot directly export callable functions.",
			" *~ This file should be imported using the CommonJS-style:",
			" *~   import x = require('someLibrary');",
			" *~",
			" *~ Refer to the documentation to understand common",
			" *~ workarounds for this limitation of ES6 modules.",
			" */",
			"",
			"/*~ If this module is a UMD module that exposes a global variable '${1:myFuncLib}' when",
			" *~ loaded outside a module loader environment, declare that global here.",
			" *~ Otherwise, delete this declaration.",
			" */",
			"export as namespace ${1:myFuncLib};",
			"",
			"/*~ This declaration specifies that the function",
			" *~ is the exported object from the file",
			" */",
			"export = ${2:MyFunction};",
			"",
			"/*~ This example shows how to have multiple overloads for your function */",
			"declare function ${2:MyFunction}(name: string): ${2:MyFunction}.NamedReturnType;",
			"declare function ${2:MyFunction}(length: number): ${2:MyFunction}.LengthReturnType;",
			"",
			"/*~ If you want to expose types from your module as well, you can",
			" *~ place them in this block. Often you will want to describe the",
			" *~ shape of the return type of the function; that type should",
			" *~ be declared in here, as this example shows.",
			" */",
			"declare namespace ${2:MyFunction} {",
			"    export interface LengthReturnType {",
			"        width: number;",
			"        height: number;",
			"    }",
			"    export interface NamedReturnType {",
			"        firstName: string;",
			"        lastName: string;",
			"    }",
			"",
			"    /*~ If the module also has properties, declare them here. For example,",
			"     *~ this declaration says that this code is legal:",
			"     *~   import f = require('myFuncLibrary');",
			"     *~   console.log(f.defaultName);",
			"     */",
			"    export const defaultName: string;",
			"    export let defaultLength: number;",
			"}"
		],
		"description": "template for *.d.ts module (function)"
	},
	"module *.d.ts template (class)": {
		"prefix": "module class",
		"body": [
			"// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]",
			"// Project: [~THE PROJECT NAME~]",
			"// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>",
			"",
			"/*~ This is the module template file for class modules.",
			" *~ You should rename it to index.d.ts and place it in a folder with the same name as the module.",
			" *~ For example, if you were writing a file for \"super-greeter\", this",
			" *~ file should be 'super-greeter/index.d.ts'",
			" */",
			"",
			"/*~ Note that ES6 modules cannot directly export class objects.",
			" *~ This file should be imported using the CommonJS-style:",
			" *~   import x = require('someLibrary');",
			" *~",
			" *~ Refer to the documentation to understand common",
			" *~ workarounds for this limitation of ES6 modules.",
			" */",
			"",
			"/*~ If this module is a UMD module that exposes a global variable '${1:myClassLib}' when",
			" *~ loaded outside a module loader environment, declare that global here.",
			" *~ Otherwise, delete this declaration.",
			" */",
			"export as namespace ${1:myClassLib};",
			"",
			"/*~ This declaration specifies that the class constructor function",
			" *~ is the exported object from the file",
			" */",
			"export = ${2:MyClass};",
			"",
			"/*~ Write your module's methods and properties in this class */",
			"declare class ${2:MyClass} {",
			"    constructor(someParam?: string);",
			"",
			"    someProperty: string[];",
			"",
			"    myMethod(opts: ${2:MyClass}.MyClassMethodOptions): number;",
			"}",
			"",
			"/*~ If you want to expose types from your module as well, you can",
			" *~ place them in this block.",
			" */",
			"declare namespace ${2:MyClass} {",
			"    export interface MyClassMethodOptions {",
			"        width?: number;",
			"        height?: number;",
			"    }",
			"}",
		],
		"description": "template for *.d.ts module (class)"
	},
	"module *.d.ts template": {
		"prefix": "module globvar",
		"body": [
			"// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]",
			"// Project: [~THE PROJECT NAME~]",
			"// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>",
			"",
			"/*~ This is the module template file. You should rename it to index.d.ts",
			" *~ and place it in a folder with the same name as the module.",
			" *~ For example, if you were writing a file for \"super-greeter\", this",
			" *~ file should be 'super-greeter/index.d.ts'",
			" */",
			"",
			"/*~ If this module is a UMD module that exposes a global variable '${1:myLib}' when",
			" *~ loaded outside a module loader environment, declare that global here.",
			" *~ Otherwise, delete this declaration.",
			" */",
			"export as namespace ${1:myLib};",
			"",
			"/*~ If this module has methods, declare them as functions like so.",
			" */",
			"export function myMethod(a: string): string;",
			"export function myOtherMethod(a: number): number;",
			"",
			"/*~ You can declare types that are available via importing the module */",
			"export interface someType {",
			"    name: string;",
			"    length: number;",
			"    extras?: string[];",
			"}",
			"",
			"/*~ You can declare properties of the module using const, let, or var */",
			"export const myField: number;",
			"",
			"/*~ If there are types, properties, or methods inside dotted names",
			" *~ of the module, declare them inside a 'namespace'.",
			" */",
			"export namespace subProp {",
			"    /*~ For example, given this definition, someone could write:",
			"     *~   import { subProp } from 'yourModule';",
			"     *~   subProp.foo();",
			"     *~ or",
			"     *~   import * as yourMod from 'yourModule';",
			"     *~   yourMod.subProp.foo();",
			"     */",
			"    export function foo(): void;",
			"}",
		],
		"description": "Log output to console"
	}
}